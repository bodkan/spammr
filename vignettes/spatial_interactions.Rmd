---
title: "Spatial interaction dynamics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spatial interaction dynamics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4,
  dpi = 80
)
```

```{r, echo = FALSE}
devtools::load_all(".")
```

In addition to builing models that capture spatial dynamics such as movement (displacement) or expansion conveniently using a set of [simple R functions](../reference/index.html#section-population-dynamics) which do the work worth of hundreds of lines of Eidos code for you, *slendr* makes it possible to tweak more subtle characteristics of spatial population genetic models.

Among such characteristics are so called spatial interactions, described in a very detailed way in chapter 15 of SLiM's [extensive manual](http://benhaller.com/slim/SLiM_Manual.pdf). Again, describing SLiM's functionality in detail is very much beyond the scope of *slendr*'s tutorial vignettes such as this one. However, broadly speaking, *slendr* implements three different kinds of spatial interactions or dispersal parameters:

1.  *Spatial competition distance* - governed by *slendr* parameter `competition_dist` which signifies the maximum distance at which two individuals can influence each other's fitness via competition.
2.  *Mate choice* *distance* - governed by the parameter `mate_dist`, determining how far does an individual pick a potential mate.
3.  *Dispersal distance* - determined by the parameter `dispersal_dist` which establishes how far from a parent can offspring migrate until the next generation (when it can potentially become a parent itself). More accurately, this parameter determines the standard deviation of a normal distribution of such dispersal distances.

All three parameters can be specified for each simulated population individually. Alternatively, default values for these parameters can be given in a `compile()` call. Importantly, a population must be given the values of all three of these parameters, be it specific values for that particular population or a default value during compilation.

Finally, as with other functions for programming model spatial dynamics, the *slendr* package provides a simple way to program the spatial interaction dynamics throughout the course of the simulation. Even complex models can be programmed using only a couple of lines of extremely simple R code, resulting in a robust SLiM simulation script being generated under the hood.

To demonstrate this feature, let's look at a simple example. We will focus only on programming spatial interaction dynamics and will leave many other functions that we covered in the extensive [tutorial vignette](slendr.html).

```{r, eval = FALSE}
library(slendr)
```

Here is a single population *pop* which occupies a square, blank landscape 100 distance units on each side. The population has a circular range, appears at time 1 (this model will be specified in forward time direction) and has a size of 3000 individuals.

```{r abstract_world}
blank_world <- world(
  xrange = c(0, 100),
  yrange = c(0, 100),
  landscape = "blank"
)

pop <- population(
  name = "pop", time = 1, N = 3000,
  map = blank_world, center = c(50, 50), radius = 50,
  competition_dist = 5, mate_dist = 5, dispersal_dist = 1
)

plot(pop)
```

Note that we also specified the values of each of the three spatial parameters. They are given in distance units corresponding to the coordinate reference system of the underlying world map (i.e. the world map is 100 distance units wide and 100 distance units tall).

Next, we will program a series of five changes in the competition distance parameter of this population. To do this, we will use the fact that most of *slendr*'s functions implement a tidyverse pipe-friendly interface, which makes model specification code very concise and readable.

```{r}
pop <- pop %>%
  dispersal(time = 100, competition_dist = 10) %>%
  dispersal(time = 200, competition_dist = 40) %>%
  dispersal(time = 300, competition_dist = 60) %>%
  dispersal(time = 400, competition_dist = 80) %>%
  dispersal(time = 500, competition_dist = 100, dispersal_dist = 5)
```

Finally, we will compile this model and execute the simulation. Note that because we are working with a forward time model, we need to specify the total length of the simulation to know when to terminate it. Also, we specify a short burnin to let the initial spatial distribution settle down based on the initial spatial interaction distances. We will save the spatial locations of all individuals in order to visualize the spatial population dynamics with an animation later.

```{r, echo = FALSE}
unlink("/tmp/spatial-interactions", recursive = TRUE, force = TRUE); 
```

```{r}
model <- compile(populations = pop, generation_time = 1, resolution = 1,
                 dir = "/tmp/spatial-interactions/", sim_length = 800)

slim(model, burnin = 300, seq_length = 1, recomb_rate = 0,
     save_locations = TRUE, method = "batch")
```

Of course, it needs to be said that unlike the spatial population dynamics functionality described largely in the [tutorial](slendr.html) which is a unique feature of _slendr_, the example in this vignette could be reproduced in pure SLiM using vanilla Eidos code. However, I think it is fair to say that the about dozen lines of consise R code necessary to do this using our R interface is much more flexible and easy to tweak and extend towards much more complex scenarios.
